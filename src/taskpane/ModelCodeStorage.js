/**
 * Model Code Storage and Tab Replacement System
 * Manages storing model codes and updating specific tabs when new codes are created
 */

/**
 * Stores the complete model codes for future reference and updates
 * @param {string} modelCodes - The complete model codes string
 */
export function storeModelCodes(modelCodes) {
    try {
        if (!modelCodes || typeof modelCodes !== 'string') {
            console.warn("[ModelCodeStorage] Invalid model codes provided");
            return;
        }
        
        const timestamp = new Date().toISOString();
        const timestampedCodes = `// Model codes last updated on ${timestamp}\n// Generated by AI Model Planner\n\n${modelCodes}`;
        
        // Store both timestamped and raw versions
        localStorage.setItem('lastModelCodes', timestampedCodes);
        localStorage.setItem('rawModelCodes', modelCodes);
        
        console.log("[ModelCodeStorage] Model codes stored successfully");
        
    } catch (error) {
        console.error("[ModelCodeStorage] Error storing model codes:", error);
    }
}

/**
 * Retrieves the stored model codes
 * @param {boolean} includeTimestamp - Whether to include timestamp header (default: false)
 * @returns {string|null} - The stored model codes or null if not found
 */
export function getStoredModelCodes(includeTimestamp = false) {
    try {
        const key = includeTimestamp ? 'lastModelCodes' : 'rawModelCodes';
        const storedCodes = localStorage.getItem(key);
        
        if (storedCodes && storedCodes.trim()) {
            console.log("[ModelCodeStorage] Retrieved model codes from storage");
            return storedCodes;
        } else {
            console.log("[ModelCodeStorage] No model codes found in storage");
            return null;
        }
        
    } catch (error) {
        console.error("[ModelCodeStorage] Error retrieving model codes:", error);
        return null;
    }
}

/**
 * Updates a specific tab in the stored model codes with new coding
 * @param {string} tabName - The name of the tab to update
 * @param {string} newTabCodes - The new codes for this tab
 * @returns {string|null} - The updated complete model codes or null if error
 */
export function updateTabInStoredCodes(tabName, newTabCodes) {
    try {
        console.log(`[ModelCodeStorage] Updating tab "${tabName}" in stored codes`);
        
        const currentCodes = getStoredModelCodes(false); // Get raw codes
        if (!currentCodes) {
            console.warn("[ModelCodeStorage] No existing model codes to update");
            return newTabCodes; // Return just the new codes if no existing codes
        }
        
        // Extract the TAB section for the specified tab
        const tabStartPattern = new RegExp(`<TAB;\\s*label1="${escapeRegExp(tabName)}"[^>]*>`, 'i');
        const nextTabPattern = /<TAB;\s*label1="[^"]*"[^>]*>/i;
        
        const tabStartMatch = currentCodes.match(tabStartPattern);
        if (!tabStartMatch) {
            console.log(`[ModelCodeStorage] Tab "${tabName}" not found in existing codes, appending new codes`);
            // If tab doesn't exist, append the new codes
            return currentCodes + '\n\n' + newTabCodes;
        }
        
        const tabStartIndex = tabStartMatch.index;
        
        // Find the start of the next TAB section (or end of string)
        const remainingCodes = currentCodes.substring(tabStartIndex + tabStartMatch[0].length);
        const nextTabMatch = remainingCodes.match(nextTabPattern);
        
        let tabEndIndex;
        if (nextTabMatch) {
            tabEndIndex = tabStartIndex + tabStartMatch[0].length + nextTabMatch.index;
        } else {
            tabEndIndex = currentCodes.length;
        }
        
        // Replace the tab section with new codes
        const beforeTab = currentCodes.substring(0, tabStartIndex);
        const afterTab = currentCodes.substring(tabEndIndex);
        const updatedCodes = beforeTab + newTabCodes + afterTab;
        
        // Store the updated codes
        storeModelCodes(updatedCodes);
        
        console.log(`[ModelCodeStorage] Successfully updated tab "${tabName}" in stored codes`);
        return updatedCodes;
        
    } catch (error) {
        console.error(`[ModelCodeStorage] Error updating tab "${tabName}":`, error);
        return null;
    }
}

/**
 * Extracts all codes for a specific tab from the model codes string
 * @param {string} modelCodes - The complete model codes string  
 * @param {string} tabName - The name of the tab to extract
 * @returns {string|null} - The codes for the specified tab or null if not found
 */
export function extractTabCodes(modelCodes, tabName) {
    try {
        if (!modelCodes || !tabName) {
            return null;
        }
        
        const tabStartPattern = new RegExp(`<TAB;\\s*label1="${escapeRegExp(tabName)}"[^>]*>`, 'i');
        const nextTabPattern = /<TAB;\s*label1="[^"]*"[^>]*>/i;
        
        const tabStartMatch = modelCodes.match(tabStartPattern);
        if (!tabStartMatch) {
            console.log(`[ModelCodeStorage] Tab "${tabName}" not found in model codes`);
            return null;
        }
        
        const tabStartIndex = tabStartMatch.index;
        
        // Find the start of the next TAB section (or end of string)
        const remainingCodes = modelCodes.substring(tabStartIndex + tabStartMatch[0].length);
        const nextTabMatch = remainingCodes.match(nextTabPattern);
        
        let tabEndIndex;
        if (nextTabMatch) {
            tabEndIndex = tabStartIndex + tabStartMatch[0].length + nextTabMatch.index;
        } else {
            tabEndIndex = modelCodes.length;
        }
        
        const tabCodes = modelCodes.substring(tabStartIndex, tabEndIndex).trim();
        console.log(`[ModelCodeStorage] Extracted ${tabCodes.length} characters for tab "${tabName}"`);
        return tabCodes;
        
    } catch (error) {
        console.error(`[ModelCodeStorage] Error extracting tab "${tabName}":`, error);
        return null;
    }
}

/**
 * Gets a list of all tab names in the stored model codes
 * @returns {string[]} - Array of tab names found in the model codes
 */
export function getTabNamesFromStoredCodes() {
    try {
        const modelCodes = getStoredModelCodes(false);
        if (!modelCodes) {
            return [];
        }
        
        const tabPattern = /<TAB;\s*label1="([^"]*)"[^>]*>/gi;
        const tabNames = [];
        let match;
        
        while ((match = tabPattern.exec(modelCodes)) !== null) {
            tabNames.push(match[1]);
        }
        
        console.log(`[ModelCodeStorage] Found ${tabNames.length} tabs: ${tabNames.join(', ')}`);
        return tabNames;
        
    } catch (error) {
        console.error("[ModelCodeStorage] Error getting tab names:", error);
        return [];
    }
}

/**
 * Clears all stored model codes
 */
export function clearStoredModelCodes() {
    try {
        localStorage.removeItem('lastModelCodes');
        localStorage.removeItem('rawModelCodes');
        console.log("[ModelCodeStorage] Cleared all stored model codes");
    } catch (error) {
        console.error("[ModelCodeStorage] Error clearing stored model codes:", error);
    }
}

/**
 * Helper function to escape special regex characters
 * @param {string} string - String to escape
 * @returns {string} - Escaped string
 */
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Gets storage statistics for debugging
 * @returns {object} - Object with storage information
 */
export function getStorageStats() {
    try {
        const lastModelCodes = localStorage.getItem('lastModelCodes');
        const rawModelCodes = localStorage.getItem('rawModelCodes');
        
        return {
            hasTimestampedCodes: !!lastModelCodes,
            hasRawCodes: !!rawModelCodes,
            timestampedCodesLength: lastModelCodes ? lastModelCodes.length : 0,
            rawCodesLength: rawModelCodes ? rawModelCodes.length : 0,
            tabCount: getTabNamesFromStoredCodes().length
        };
    } catch (error) {
        console.error("[ModelCodeStorage] Error getting storage stats:", error);
        return {};
    }
}